#! /usr/bin/env bash
# Abort on errors
set -e

get_challenge_path(){
    challenge_group=${1}
    challenge_number=${2}

    echo "challenges/${challenge_group}/${challenge_number}"
}

is_solved(){
    challenge_group=${1}
    challenge_number=${2}

    # Make sure .results exists on first run
    touch .results
    if grep "${challenge_group}/${challenge_number}" .results; then
        echo "(solved)"
    fi
}

solved(){
    challenge_group=${1}
    challenge_number=${2}
    solution_path=${3}

    echo "${challenge_group}/${challenge_number}:${solution_path}" >> .results
    echo "Well done! You passed ${challenge_group} challenge ${challenge_number}!"
}

failed(){
    challenge_group=${1}
    challenge_number=${2}

    echo "Sorry, you didn't pass ${challenge_group} challenge ${challenge_number} this time. Try again soon!"
}

test_data_processing_challenge_attempt(){
    challenge_group=${1}
    challenge_number=${2}
    solution_file_path=${3}

    # Set up test environment
    test_path=".test/${challenge_group}/${challenge_number}"
    challenge_path="$(get_challenge_path ${challenge_group} ${challenge_number})"
    rm -rf ${test_path}
    mkdir -p ${test_path}
    cp -r "${challenge_path}/*" ${test_path}
    cd ${test_path}
    if [[ -x setup ]]; then
        setup
    fi

    chmod +x ${solution_file_path}
    echo "Comparing input and output data:"
    if sdiff <(cat start | ${solution_file_path}) finish; then
        solved ${challenge_group} ${challenge_number} ${solution_file_path}
    else
        failed ${challenge_group} ${challenge_number}
    fi
}

get_challenge_name(){
    challenge_group=${1}
    challenge_number=${2}

    challenge_path=$(get_challenge_path ${challenge_group} ${challenge_number})
    readme_path="${challenge_path}/README"
    challenge_name=$(cat ${readme_path} | head -n1)
    echo ${challenge_name}
}

get_all_challenges(){
    challenge_groups=$(ls challenges | sort)
    echo "Challenges by group:"
    for group in ${challenge_groups}; do
        echo "  ${group}"
        challenges=$(ls challenges/${group} | sort -g)
        for challenge in ${challenges}; do
            echo "    $(is_solved ${group} ${challenge})${challenge}: $(get_challenge_name ${group} ${challenge})"
        done
    done
}

make_practise(){
    challenge_group=${1}
    challenge_number=${2}

    challenge_path="$(get_challenge_path ${challenge_group} ${challenge_number})"
    practise_path="practise/${challenge_group}/${challenge_number}"

    if [[ -d ${practise_path} ]]; then
        echo "Practise directory for challenge ${challenge_number} of group ${challenge_group} already exists in: ${practise_path}"
        return 0
    fi

    if [[ -d ${challenge_path} ]]; then
        mkdir -p ${practise_path}
        cp -r ${challenge_path}/* ${practise_path}/
        if [[ -x ${practise_path}/setup ]]; then
            cd ${practise_path}
            ./setup
            cd - >/dev/null
        fi
        echo "Practise directory for challenge ${challenge_number} of group ${challenge_group} created: ${practise_path}"
    else
        if [[ -d challenges/${challenge_group} ]]; then
            echo "Could not find challenge ${challenge_number} in group ${challenge_group}"
        else
            echo "Could not find challenge group ${challenge_group}"
        fi
        return 1
    fi
}

get_all_challenges
make_practise cut 1
# TODO: Help text
# TODO: Menu-ish stuff
